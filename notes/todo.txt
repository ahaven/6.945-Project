* set implementation, type-totally:< - caseymc
  (set:make symbol? symbol? ...) --> set
  (set:add set? symbol? ...) --> set
* type data type - ahaven
  (type:make symbol? ...) --> type
  (type:make (type?) type?) --> type
  (type:union type? ...) --> type
* type:<
* built in's types - katfang


FUTURE
* set! - if it sets to a different type, is that "wrong"? Or do we just have set! change the type of the variable?

---4/23---

Goal: Put in a function's code, get its type.

* Make a version of the evaluator that analyzes type
  ** Make type-eval so that this is possible; use propagators somehow
* Decide how to "save" known typed things - put them in the environment 
  that stores all the other types?
     name -> {code} [+ {type info = cell} ]

* So how do propagators give us an answer?
  build-type-cell expr env -> cell
  primitive-application
  application
  cond
  if
  et cetera

* (build-type-cell (f e1 e2) env)
    (build-type-cell f env) -> cf
    (build-type-cell e1 env) -> ce1
    (build-type-cell e2 env) -> ce1
    (make-cell) -> cout
    ce1 <= (input-type cf 1)
    ce2 <= (input-type cf 2)
    (output-type cf) <= cout

* v      <=    t
  [3 10]       [3 10]
  vhi  := min(thi,  vhi)
  tlow := max(tlow, vlow)
